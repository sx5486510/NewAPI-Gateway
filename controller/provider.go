package controller

import (
	"NewAPI-Gateway/common"
	"NewAPI-Gateway/model"
	"NewAPI-Gateway/service"
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"
)

func GetProviders(c *gin.Context) {
	p, _ := strconv.Atoi(c.Query("p"))
	if p < 0 {
		p = 0
	}
	providers, err := model.GetAllProviders(p*common.ItemsPerPage, common.ItemsPerPage)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": err.Error()})
		return
	}
	// Clean sensitive fields
	for _, provider := range providers {
		provider.CleanForResponse()
	}
	c.JSON(http.StatusOK, gin.H{"success": true, "message": "", "data": providers})
}

func GetProviderDetail(c *gin.Context) {
	id, err := strconv.Atoi(c.Param("id"))
	if err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": "无效的 ID"})
		return
	}
	provider, err := model.GetProviderById(id)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": "供应商不存在"})
		return
	}
	provider.CleanForResponse()
	c.JSON(http.StatusOK, gin.H{"success": true, "message": "", "data": provider})
}

func GetProviderModelAliasMapping(c *gin.Context) {
	id, err := strconv.Atoi(c.Param("id"))
	if err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": "无效的 ID"})
		return
	}
	provider, err := model.GetProviderById(id)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": "供应商不存在"})
		return
	}
	mapping := model.ParseProviderAliasMapping(provider.ModelAliasMapping)
	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"message": "",
		"data":    mapping,
	})
}

func UpdateProviderModelAliasMapping(c *gin.Context) {
	id, err := strconv.Atoi(c.Param("id"))
	if err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": "无效的 ID"})
		return
	}
	provider, err := model.GetProviderById(id)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": "供应商不存在"})
		return
	}

	var req struct {
		ModelAliasMapping map[string]string `json:"model_alias_mapping"`
	}
	if err := json.NewDecoder(c.Request.Body).Decode(&req); err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": "无效的参数"})
		return
	}

	payload, err := model.MarshalProviderAliasMapping(req.ModelAliasMapping)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": "模型映射 JSON 无效"})
		return
	}
	provider.UpdateModelAliasMapping(payload)
	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"message": "",
		"data":    model.ParseProviderAliasMapping(payload),
	})
}

func ExportProviders(c *gin.Context) {
	providers, err := model.GetAllProviders(0, 1000)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": err.Error()})
		return
	}
	// Export format: include access_token for re-import
	type ExportItem struct {
		Name              string `json:"name"`
		BaseURL           string `json:"base_url"`
		AccessToken       string `json:"access_token"`
		UserID            int    `json:"user_id,omitempty"`
		Status            int    `json:"status,omitempty"`
		Priority          int    `json:"priority,omitempty"`
		Weight            int    `json:"weight,omitempty"`
		CheckinEnabled    bool   `json:"checkin_enabled,omitempty"`
		ModelAliasMapping string `json:"model_alias_mapping,omitempty"`
		Remark            string `json:"remark,omitempty"`
	}
	var items []ExportItem
	for _, p := range providers {
		items = append(items, ExportItem{
			Name:              p.Name,
			BaseURL:           p.BaseURL,
			AccessToken:       p.AccessToken,
			UserID:            p.UserID,
			Status:            p.Status,
			Priority:          p.Priority,
			Weight:            p.Weight,
			CheckinEnabled:    p.CheckinEnabled,
			ModelAliasMapping: p.ModelAliasMapping,
			Remark:            p.Remark,
		})
	}
	c.JSON(http.StatusOK, gin.H{"success": true, "message": "", "data": items})
}

func ImportProviders(c *gin.Context) {
	// Use a flexible import struct to accept user_id as string or int
	type ImportItem struct {
		Name              string            `json:"name"`
		BaseURL           string            `json:"base_url"`
		AccessToken       string            `json:"access_token"`
		UserID            json.Number       `json:"user_id"`
		Status            int               `json:"status"`
		Priority          int               `json:"priority"`
		Weight            int               `json:"weight"`
		CheckinEnabled    bool              `json:"checkin_enabled"`
		ModelAliasMapping map[string]string `json:"model_alias_mapping"`
		Remark            string            `json:"remark"`
	}
	var items []ImportItem
	if err := json.NewDecoder(c.Request.Body).Decode(&items); err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": "JSON 格式错误: " + err.Error()})
		return
	}
	imported := 0
	skipped := 0
	for _, item := range items {
		if item.Name == "" || item.BaseURL == "" || item.AccessToken == "" {
			skipped++
			continue
		}
		uid, _ := item.UserID.Int64()
		p := model.Provider{
			Name:           item.Name,
			BaseURL:        item.BaseURL,
			AccessToken:    item.AccessToken,
			UserID:         int(uid),
			Status:         item.Status,
			Priority:       item.Priority,
			Weight:         item.Weight,
			CheckinEnabled: item.CheckinEnabled,
			Remark:         item.Remark,
		}
		if payload, err := model.MarshalProviderAliasMapping(item.ModelAliasMapping); err == nil {
			p.ModelAliasMapping = payload
		}
		if p.Status == 0 {
			p.Status = 1
		}
		if p.Weight == 0 {
			p.Weight = 10
		}
		if err := p.Insert(); err != nil {
			skipped++
		} else {
			imported++
		}
	}
	msg := fmt.Sprintf("成功导入 %d 个，跳过 %d 个", imported, skipped)
	c.JSON(http.StatusOK, gin.H{"success": true, "message": msg})
}

func CreateProvider(c *gin.Context) {
	var provider model.Provider
	if err := json.NewDecoder(c.Request.Body).Decode(&provider); err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": "无效的参数"})
		return
	}
	if provider.Name == "" || provider.BaseURL == "" || provider.AccessToken == "" {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": "名称、地址和 AccessToken 不能为空"})
		return
	}
	if err := provider.Insert(); err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": err.Error()})
		return
	}
	c.JSON(http.StatusOK, gin.H{"success": true, "message": ""})
}

func UpdateProvider(c *gin.Context) {
	var provider model.Provider
	if err := json.NewDecoder(c.Request.Body).Decode(&provider); err != nil || provider.Id == 0 {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": "无效的参数"})
		return
	}
	if err := provider.Update(); err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": err.Error()})
		return
	}
	c.JSON(http.StatusOK, gin.H{"success": true, "message": ""})
}

func DeleteProvider(c *gin.Context) {
	id, err := strconv.Atoi(c.Param("id"))
	if err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": "无效的 ID"})
		return
	}
	provider := &model.Provider{Id: id}
	if err := provider.Delete(); err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": err.Error()})
		return
	}
	c.JSON(http.StatusOK, gin.H{"success": true, "message": ""})
}

func SyncProviderHandler(c *gin.Context) {
	id, err := strconv.Atoi(c.Param("id"))
	if err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": "无效的 ID"})
		return
	}
	provider, err := model.GetProviderById(id)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": "供应商不存在"})
		return
	}
	go func() {
		if err := service.SyncProvider(provider); err != nil {
			common.SysLog("sync provider failed: " + err.Error())
		}
	}()
	c.JSON(http.StatusOK, gin.H{"success": true, "message": "同步任务已启动"})
}

func CheckinProviderHandler(c *gin.Context) {
	id, err := strconv.Atoi(c.Param("id"))
	if err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": "无效的 ID"})
		return
	}
	provider, err := model.GetProviderById(id)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": "供应商不存在"})
		return
	}
	if err := service.CheckinProvider(provider); err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": "签到失败: " + err.Error()})
		return
	}
	c.JSON(http.StatusOK, gin.H{"success": true, "message": "签到成功"})
}

func GetProviderTokens(c *gin.Context) {
	id, err := strconv.Atoi(c.Param("id"))
	if err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": "无效的 ID"})
		return
	}
	tokens, err := model.GetProviderTokensByProviderId(id)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": err.Error()})
		return
	}
	for _, t := range tokens {
		t.CleanForResponse()
	}
	c.JSON(http.StatusOK, gin.H{"success": true, "message": "", "data": tokens})
}

func GetProviderPricing(c *gin.Context) {
	id, err := strconv.Atoi(c.Param("id"))
	if err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": "无效的 ID"})
		return
	}
	provider, err := model.GetProviderById(id)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": "供应商不存在"})
		return
	}
	pricing, err := model.GetModelPricingByProvider(id)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": err.Error()})
		return
	}

	groupRatio := map[string]float64{}
	if provider.PricingGroupRatio != "" {
		_ = json.Unmarshal([]byte(provider.PricingGroupRatio), &groupRatio)
	}

	supportedEndpoint := map[string]map[string]string{}
	if provider.PricingSupportedEndpoint != "" {
		_ = json.Unmarshal([]byte(provider.PricingSupportedEndpoint), &supportedEndpoint)
	}

	c.JSON(http.StatusOK, gin.H{
		"success":            true,
		"message":            "",
		"data":               pricing,
		"group_ratio":        groupRatio,
		"supported_endpoint": supportedEndpoint,
	})
}

func CreateProviderToken(c *gin.Context) {
	providerId, err := strconv.Atoi(c.Param("id"))
	if err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": "无效的供应商 ID"})
		return
	}
	provider, err := model.GetProviderById(providerId)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": "供应商不存在"})
		return
	}
	var req struct {
		Name           string `json:"name"`
		GroupName      string `json:"group_name"`
		UnlimitedQuota bool   `json:"unlimited_quota"`
		RemainQuota    int64  `json:"remain_quota"`
		ModelLimits    string `json:"model_limits"`
	}
	if err := json.NewDecoder(c.Request.Body).Decode(&req); err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": "无效的参数"})
		return
	}
	// Call upstream to create token (upstream generates SK key)
	client := service.NewUpstreamClient(provider.BaseURL, provider.AccessToken, provider.UserID)
	if err := client.CreateUpstreamToken(req.Name, req.GroupName, req.UnlimitedQuota, req.RemainQuota, req.ModelLimits); err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": "上游创建 Token 失败: " + err.Error()})
		return
	}
	// Sync tokens back to get the newly created token
	go func() {
		if err := service.SyncProvider(provider); err != nil {
			common.SysLog("sync after create token failed: " + err.Error())
		}
	}()
	c.JSON(http.StatusOK, gin.H{"success": true, "message": "Token 已在上游创建，正在同步回本地"})
}

func UpdateProviderToken(c *gin.Context) {
	tokenId, err := strconv.Atoi(c.Param("token_id"))
	if err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": "无效的 Token ID"})
		return
	}
	var token model.ProviderToken
	if err := json.NewDecoder(c.Request.Body).Decode(&token); err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": "无效的参数"})
		return
	}
	token.Id = tokenId
	if err := token.Update(); err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": err.Error()})
		return
	}
	c.JSON(http.StatusOK, gin.H{"success": true, "message": ""})
}

func DeleteProviderToken(c *gin.Context) {
	tokenId, err := strconv.Atoi(c.Param("token_id"))
	if err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": "无效的 Token ID"})
		return
	}
	token, err := model.GetProviderTokenById(tokenId)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": "Token 不存在"})
		return
	}
	// If this token came from upstream, delete upstream first; otherwise it will be re-synced later.
	if token.UpstreamTokenId > 0 {
		provider, err := model.GetProviderById(token.ProviderId)
		if err != nil {
			c.JSON(http.StatusOK, gin.H{"success": false, "message": "供应商不存在"})
			return
		}
		client := service.NewUpstreamClient(provider.BaseURL, provider.AccessToken, provider.UserID)
		if err := client.DeleteUpstreamToken(token.UpstreamTokenId); err != nil {
			c.JSON(http.StatusOK, gin.H{"success": false, "message": "上游删除 Token 失败: " + err.Error()})
			return
		}
	}
	if err := token.Delete(); err != nil {
		c.JSON(http.StatusOK, gin.H{"success": false, "message": err.Error()})
		return
	}
	c.JSON(http.StatusOK, gin.H{"success": true, "message": ""})
}
